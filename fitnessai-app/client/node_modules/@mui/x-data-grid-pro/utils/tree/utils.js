import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
import _toPropertyKey from "@babel/runtime/helpers/esm/toPropertyKey";
import _extends from "@babel/runtime/helpers/esm/extends";
import { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';
export const getGroupRowIdFromPath = path => {
  const pathStr = path.map(groupingCriteria => `${groupingCriteria.field}/${groupingCriteria.key}`).join('-');
  return `auto-generated-row-${pathStr}`;
};
export const getNodePathInTree = ({
  id,
  tree
}) => {
  const path = [];
  let node = tree[id];
  while (node.id !== GRID_ROOT_GROUP_ID) {
    path.push({
      field: node.type === 'leaf' ? null : node.groupingField,
      key: node.groupingKey
    });
    node = tree[node.parent];
  }
  path.reverse();
  return path;
};
export const addGroupDefaultExpansion = ({
  node,
  isGroupExpandedByDefault,
  defaultGroupingExpansionDepth
}) => {
  let childrenExpanded;
  if (node.id === GRID_ROOT_GROUP_ID) {
    childrenExpanded = true;
  } else if (isGroupExpandedByDefault) {
    childrenExpanded = isGroupExpandedByDefault(node);
  } else {
    childrenExpanded = defaultGroupingExpansionDepth === -1 || defaultGroupingExpansionDepth > node.depth;
  }
  return _extends({}, node, {
    childrenExpanded
  });
};

/**
 * Insert a node in the tree
 */
export const insertNodeInTree = ({
  node,
  tree,
  treeDepths
}) => {
  var _treeDepths$node$dept;
  // 1. Insert node in the tree.
  tree[node.id] = node;

  // 2. Increment the `treeDepths` object for the node's depth.
  treeDepths[node.depth] = ((_treeDepths$node$dept = treeDepths[node.depth]) != null ? _treeDepths$node$dept : 0) + 1;

  // 3. Register the new node in its parent.
  const parentNode = tree[node.parent];
  if (node.type === 'footer') {
    // For footers,
    // Register the node from its parent `footerId` property.
    tree[node.parent] = _extends({}, parentNode, {
      footerId: node.id
    });
  } else if (node.type === 'group' || node.type === 'leaf') {
    var _groupingField, _groupingKey, _parentNode$childrenF;
    // For groups and leaves,
    // Register the node from its parents `children` and `childrenFromPath` properties.
    const groupingField = (_groupingField = node.groupingField) != null ? _groupingField : '__no_field__';
    const groupingKey = (_groupingKey = node.groupingKey) != null ? _groupingKey : '__no_key__';
    tree[node.parent] = _extends({}, parentNode, {
      childrenFromPath: _extends({}, parentNode.childrenFromPath, {
        [groupingField]: _extends({}, (_parentNode$childrenF = parentNode.childrenFromPath) == null ? void 0 : _parentNode$childrenF[groupingField], {
          [groupingKey.toString()]: node.id
        })
      }),
      children: [...parentNode.children, node.id]
    });
  }
};

/**
 * Removes a node from the tree
 */
export const removeNodeFromTree = ({
  node,
  tree,
  treeDepths
}) => {
  // 1. Remove node from the tree.
  delete tree[node.id];

  // 2. Decrement the `treeDepths` object for the node's depth.
  const nodeDepth = node.depth;
  const currentNodeCount = treeDepths[nodeDepth];
  if (currentNodeCount === 1) {
    delete treeDepths[nodeDepth];
  } else {
    treeDepths[nodeDepth] = currentNodeCount - 1;
  }

  // 3. Unregister the new node in its parent.
  const parentNode = tree[node.parent];
  // For footers,
  // Unregister the node from its parent `footerId` property.
  if (node.type === 'footer') {
    tree[parentNode.id] = _extends({}, parentNode, {
      footerId: null
    });
  }
  // For groups and leaves,
  // Unregister the node from its parents `children` and `childrenFromPath` properties.
  else {
    var _groupingField2, _groupingKey2, _parentNode$childrenF2, _parentNode$childrenF3;
    const groupingField = (_groupingField2 = node.groupingField) != null ? _groupingField2 : '__no_field__';
    const groupingKey = (_groupingKey2 = node.groupingKey) != null ? _groupingKey2 : '__no_key__';
    const _ref = (_parentNode$childrenF2 = (_parentNode$childrenF3 = parentNode.childrenFromPath) == null ? void 0 : _parentNode$childrenF3[groupingField]) != null ? _parentNode$childrenF2 : {},
      _groupingKey$toString = groupingKey.toString(),
      newChildrenFromPathWithField = _objectWithoutPropertiesLoose(_ref, [_groupingKey$toString].map(_toPropertyKey));

    // TODO rows v6: Can we avoid this linear complexity ?
    const children = parentNode.children.filter(childId => childId !== node.id);
    const childrenFromPath = _extends({}, parentNode.childrenFromPath);
    if (Object.keys(newChildrenFromPathWithField).length === 0) {
      delete childrenFromPath[groupingField];
    } else {
      childrenFromPath[groupingField] = newChildrenFromPathWithField;
    }
    tree[parentNode.id] = _extends({}, parentNode, {
      children,
      childrenFromPath
    });
  }
};

/**
 * Updates the `id` and `isAutoGenerated` properties of a group node.
 */
export const updateGroupNodeIdAndAutoGenerated = ({
  node,
  updatedNode,
  tree,
  treeDepths
}) => {
  // 1. Set the new parent for all children from the old group
  node.children.forEach(childId => {
    tree[childId] = _extends({}, tree[childId], {
      parent: updatedNode.id
    });
  });

  // 2. Remove the old group from the tree
  removeNodeFromTree({
    node,
    tree,
    treeDepths
  });

  // 3. Add the new group in the tree
  const groupNode = _extends({}, node, updatedNode);
  insertNodeInTree({
    node: groupNode,
    tree,
    treeDepths
  });
};
export const createUpdatedGroupsManager = () => ({
  value: {},
  addAction(groupId, action) {
    if (!this.value[groupId]) {
      this.value[groupId] = {};
    }
    this.value[groupId][action] = true;
  }
});